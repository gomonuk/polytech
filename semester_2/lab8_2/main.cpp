/**
Created by gomonuk on 04.04.19.

 Разработать программу, которая:
a. Реализует иерархию геометрических фигур состоящую из:
     i.Класс Shape.
         1.Содержит информацию о положении центра фигуры (координаты x и y).
         2.Содердит метод IsMoreLeft, позволяющий определить расположена ли данная фигура
           левее (определяется по положению центра) чем фигура переданная в качестве аргумента
         3.Содердит метод IsUpper, позволяющий определить расположена ли данная фигура
           выше (определяется по положению центра) чем фигура переданная в качестве аргумента
         4.Определяет чисто виртаульную функцию рисования Draw
          (каждая фигура в реализации этой функци должна выводить на стандартный вывод свое название и положение центра)

     ii.Класс Circle производный от класса Shape
         1.Реализует Draw
     iii.Класс Triangle производный от класса Shape
         1.Реализует Draw
     iv.Класс Square производный от класса Shape
         1.Реализует Draw

b. Содержит список list<Shape*>, заполенный указателями на различные фигуры
c. С помощью стандартных алгоритмов и адаптеров выводит (Draw) все фигуры
d. С помощью стандартных алгоритмов и адаптеров сортирует список по положению центра
   слева-направо (имется в виду, что в начале списка должны идти фигуры находящиеся
   левее, координата x ) и выводит фигуры (Draw)
e. С помощью стандартных алгоритмов и адаптеров сортирует список по положению центра
   справа-налево и выводит фигуры
f. С помощью стандартных алгоритмов и адаптеров сортирует список по положению центра
   сверху-вниз и выводит фигуры
g. С помощью стандартных алгоритмов и адаптеров сортирует список по положению центра
   снизу-вверх и выводит фигуры
*/


#include <algorithm>
#include <vector>
#include "shape.h"


int main(){

    Circle c = Circle();
    Triangle t = Triangle();
    Square s = Square();

    Circle c1 = Circle();
    Triangle t1 = Triangle();
    Square s1 = Square();

    // b. Содержит список list<Shape*>, заполенный указателями на различные фигуры
    std::vector<shape *> a ;
    a.push_back(&c);
    a.push_back(&t);
    a.push_back(&s);
    a.push_back(&c1);
    a.push_back(&t1);
    a.push_back(&s1);

    // c. С помощью стандартных алгоритмов и адаптеров выводит (Draw) все фигуры
    std::for_each(a.begin(), a.end(), [] (shape* s) { s->Draw();});


    // d. С помощью стандартных алгоритмов и адаптеров сортирует список по положению центра слева-направо
    std::cout << "\nСортируем по X, слева-направо \n";
    std::sort(a.begin(), a.end(),
            [] ( shape * af,  shape * b) -> bool {
                    return af->IsMoreLeft(*b);
//                    return af->x < b->x;
                });

    std::for_each(a.begin(), a.end(), [] (shape* s) { s->Draw();});
    std::cout << std::endl;


    // e. С помощью стандартных алгоритмов и адаптеров сортирует список по положению центра справа-налево и выводит фигуры
    std::cout << "\nСортируем по X, справо-налево\n";
    std::sort(a.begin(), a.end(),
              [] ( shape * af,  shape * b) -> bool {
                  return  !(af->IsMoreLeft(*b));
                });

    std::for_each(a.begin(), a.end(), [] (shape* s) { s->Draw();});
    std::cout << std::endl;


    // f. С помощью стандартных алгоритмов и адаптеров сортирует список по положению центра сверху-вниз и выводит фигуры
    std::cout << "\nСортируем по Y, сверху-вниз\n";
    std::sort(a.begin(), a.end(),
              [] (const shape * af, const shape * b) -> bool {
                  return af->IsUpper(*b);
                });

    std::for_each(a.begin(), a.end(), [] (shape* s) { s->Draw();});
    std::cout << std::endl;


    // g. С помощью стандартных алгоритмов и адаптеров сортирует список по положению центра снизу-вверх и выводит фигуры    std::cout << "\n Сортируем по Y, сверху-вниз\n";
    std::cout << "\nСортируем по Y, снизу-вверх\n";
    std::sort(a.begin(), a.end(),
              [] (const shape * af, const shape * b) -> bool {
                  return !(af->IsUpper(*b));
              });

    std::for_each(a.begin(), a.end(), [] (shape* s) { s->Draw();});
    std::cout << std::endl;

    return 0;
}
